---
title:
author: "Samantha Hunter"
date: "10/05/2021"
output: html_document
---

```{r echo=FALSE, message = FALSE, eval = FALSE}
rmarkdown::render("../PokeAPI_Vignette.md",
    output_format = "github_document",
    output_dir = "_posts/",
    output_options = list(
        html_preview = FALSE,
        toc = TRUE)
  )
```


Here we are going to show how to retrieve data from the [PokeAPI](https://pokeapi.co/) from six endpoints using functions that I have created. First we're going to walk through the functions and then we will do a bit of data exploration.

As a general note, while it is possible to query these endpoints using numbers, I do not recommend it. For example, in the Ability endpoint, there are 327 abilities, but you can only query up to ability 267 using the index number. After that, you must use the ability name to get data about that ability. To help with this issue, I have provided **a couple lines of code** before each function that will result in a list of all available index names that you can query by or you can use the resulting list to query the entire endpoint as I have done in the data exploration.


# Required R Packages
```{r echo = FALSE, message = FALSE}
# Library for reading data from the API
library(httr)
library(jsonlite)

# Unlisting
library(purrr)
library(data.table)

# Data Manipulation
library(tidyverse)
library(dplyr)
```

The following packages were used to query the API:
  `httr`: used to connect to the API via URL
  `jsonlite`: used to decode the information we got from the API into plain text
  `purr`: used to unlist the output from the API
  `data.table`: used to combine the lists into a single dataframe

The following packages were used for the data exploration:
  `tidyverse`: used for data manipulation and visualization


# Functions to Query PokeAPI

## Ability

The `ability` function interacts with the `ability` endpoint of the PokeAPI. The function returns a tibble with an observation for each pokemon that has the ability and what generation the ability was introduced in.

###
#
###

```{r}
# Finding a list of all available abilities
avail_ability <- GET("https://pokeapi.co/api/v2/ability/?limit=327&offset=0")
avail_ability <- rawToChar(avail_ability$content)
avail_ability <- fromJSON(avail_ability)
avail_ability <- avail_ability[["results"]][["name"]]

ability <- function(name, ...){
  ###
  # This function takes the name of the abilities supplied and returns
  # data about the Pokemon that can use this ability, what generation
  # of game the ability originated in
  ###

  url_ability <- paste0("https://pokeapi.co/api/v2/ability/", avail_ability)
  poke_bility <- lapply(url_ability, GET)
  poke_bility <- lapply(poke_bility, '[[', 'content')
  poke_bility <- lapply(poke_bility, rawToChar)
  poke_bility <- lapply(poke_bility, fromJSON)

  # Unlisting our data from the API so that we can create a tidy data frame
  abilities <- (map(poke_bility, "name"))
  ability_pokemon <- (map(map(map(poke_bility, "pokemon"), "pokemon"), "name"))
  ability_generation <- map(map(poke_bility, "generation"), "name")

  # Creating a list of tibbles
  Pokemon_Ability <- list(rep(0, length(unlist(ability_pokemon))))
    for(a in 1:length(ability_pokemon)){
      Pokemon <- unlist(ability_pokemon[a])
      Ability <- rep(abilities[[a]], length(ability_pokemon[a]))
      Generation <- rep(ability_generation[[a]], length(ability_pokemon[a]))
      Pokemon_Ability[[a]] <- as_tibble(cbind(Pokemon, Ability, Generation))
    }

  # Combining our list of tibbles into one tibble
  Pokemon_Ability <- rbindlist(Pokemon_Ability, fill = TRUE)
  return(Pokemon_Ability)
}

```


## Pokemon Type

While there are 20 possible Pokemon types, I'm not interested the information offered in the shadow or unknown Pokemon. The shadow Pokemon only offers moves that are available for that Pokemon type. The unknown Pokemon only have data about the generation of game that this Pokemon type appeared in.

For the other Pokemon types, you can query this either by numbers, 1 through 18, or with the name of the Pokemon type. The resulting tibble will only contain information about the Pokemon and the type it is. Some Pokemon do have more than one type.


```{r}
# Finding a list of all possible Pokemon types
avail_types <- GET("https://pokeapi.co/api/v2/type/?limit=20&offset=0")
avail_types <- rawToChar(avail_types$content)
avail_types <- fromJSON(avail_types)
avail_types <- avail_types[["results"]][["name"]]

type <- function(name, ...){
  ###
  # This function takes the Pokemon types and returns all the Pokemon
  # of that type.
  ###
  url_type <- paste0("https://pokeapi.co/api/v2/type/", (c(name, ...)))
  poke_type <- lapply(url_type, GET)
  poke_type <-lapply(poke_type, '[[', 'content')
  poke_type <- lapply(poke_type, rawToChar)
  poke_type <- lapply(poke_type, fromJSON)

  # Unlisting our data from the API so that we can create a tidy data frame
  types <- map(poke_type, "name")
  type_pokemon <- map(map(map(poke_type, "pokemon"), "pokemon"), "name")

  # Creating a list of tibbles
  Pokemon_Type <- list(rep(0, length(unlist(types))))
  for(a in 1:length(types)){
    Pokemon <- unlist(type_pokemon[a])
    Type <- rep(types[[a]], length(type_pokemon[a]))
    Pokemon_Type[[a]] <- as_tibble(cbind(Pokemon, Type))
  }

  # Combining our list of tibbles into one tibble
  Pokemon_Type <- rbindlist(Pokemon_Type)
  return(Pokemon_Type)
}

```

## Generation

In Pokemon, generations are generally regarded as when a 'batch' of new Pokemon species are released and new game mechanics are added to the video games. This function will return a tibble with observations for each Pokemon species that was introduced in that generation.

```{r}
# Finding a list of all available generations
avail_gen <- GET("https://pokeapi.co/api/v2/generation/")
avail_gen <- rawToChar(avail_gen$content)
avail_gen <- fromJSON(avail_gen)
avail_gen <- avail_gen[["results"]][["name"]]

generation <- function(name, ...){
  ###
  # This function takes the name of the generations supplied and returns
  # the Pokemon that was first introduced in that generation.
  ###
  url_gen <- paste0("https://pokeapi.co/api/v2/generation/", c(name, ...))
  poke_gen <- lapply(url_gen, GET)
  poke_gen <- lapply(poke_gen, '[[', 'content')
  poke_gen <- lapply(poke_gen, rawToChar)
  poke_gen <- lapply(poke_gen, fromJSON)
  
  # Unlisting our data from the API so that we can create a tidy data frame
  gen <- map(poke_gen, "name")
  gen_poke <- map(map(poke_gen, "pokemon_species"), "name")
  
  # Creating a list of tibbles
  Pokemon_Generation <- list(rep(0, length(unlist(gen_poke))))
  for(a in 1:length(gen_poke)){
    Pokemon <- unlist(gen_poke[a])
    Generation <- rep(gen[[a]], length(gen_poke[a]))
    Pokemon_Generation[[a]] <- as.tibble(cbind(Generation, Pokemon))
  }
  
  # Combining our list of tibbles into one tibble
  Pokemon_Generation <- rbindlist(Pokemon_Generation)
  return(Pokemon_Generation)
}
```


## Habitat

This function queries what type of environment Pokemon can be found. It will return a tibble of the Pokemon that can be found in a habitat. 

```{r}
# Finding a list of all available habitats
avail_habitat <- GET("https://pokeapi.co/api/v2/pokemon-habitat/?limit=20&offset=0")
avail_habitat <- rawToChar(avail_habitat$content)
avail_habitat <- fromJSON(avail_habitat)
avail_habitat <- avail_habitat[["results"]][["name"]]

habitat <- function(name, ...){
  ###
  # This function takes the name of the habitat and returns what Pokemon that
  # can be found in that habitat
  ###
  url_habitat <- paste0("https://pokeapi.co/api/v2/pokemon-habitat/", c(name, ...))
  poke_habitat <- lapply(url_habitat, GET)
  poke_habitat <-lapply(poke_habitat, '[[', 'content')
  poke_habitat <- lapply(poke_habitat, rawToChar)
  poke_habitat <- lapply(poke_habitat, fromJSON)

  # Unlisting our data from the API so that we can create a tidy data frame
  habitat <- map(poke_habitat, "name")
  habitat_poke <- map(map(poke_habitat, "pokemon_species"), "name")

  # Creating a list of tibbles
  Pokemon_Habitat <- list(rep(0, length(unlist(habitat_poke))))
  for(a in 1:length(habitat_poke)){
    Pokemon <- unlist(habitat_poke[a])
    Habitat <- rep(habitat[[a]], length(habitat_poke[a]))
    Pokemon_Habitat[[a]] <- as_tibble(cbind(Habitat, Pokemon))
  }

  # Combining our list of tibbles into one tibble
  Pokemon_Habitat <- rbindlist(Pokemon_Habitat)
  return(Pokemon_Habitat)

}
```


## Berries

Berries are in-game items that can heal status effects, restore health points, or have some other effect on Pokemon the berry is fed to. This function will take the name of the berry and return how long it takes the berry to grow on a bush and the maximum number of berries on a bush.


```{r}
# Finding a list of all available berries
avail_berry <- GET("https://pokeapi.co/api/v2/berry?offset=0&limit=200")
avail_berry <- rawToChar(avail_berry$content)
avail_berry <- fromJSON(avail_berry)
avail_berry <- avail_berry[["results"]][["name"]]

berry <- function(name, ...){
  ###
  # This function takes the name of the berry and returns data about
  # the germination period of berries and the number of fruit the bush bears
  ###
  url_berry <- paste0("https://pokeapi.co/api/v2/berry/", c(name, ...))
  poke_berry <- lapply(url_berry, GET)
  poke_berry <- lapply(poke_berry, '[[', 'content')
  poke_berry <- lapply(poke_berry, rawToChar)
  poke_berry <- lapply(poke_berry, fromJSON)

  # Unlisting our data from the API so that we can create a tidy data frame
  berries <- unlist(map(poke_berry, "name"))
  growth_time <- unlist(map(poke_berry, "growth_time"))
  max_harvest <- unlist(map(poke_berry, "max_harvest"))

  # Combining tibbles into one tibble
  Pokemon_Berry <- as_tibble(cbind(berries, growth_time, max_harvest))
  return(Pokemon_Berry)
}
```


## Pokemon Base Stats


Here we get the base stats of all available Pokemon, as well as what generation the pokemon belongs to. There are six available stats in the Pokemon endpoint - hp, attack, defense, special attack, special defense, and speed.


```{r}
# Finding a list of all possible Pokemon
avail_pokemon <- GET("https://pokeapi.co/api/v2/pokemon/?limit=1200&offset=0")
avail_pokemon <- rawToChar(avail_pokemon$content)
avail_pokemon <- fromJSON(avail_pokemon)
avail_pokemon <- avail_pokemon[["results"]][["name"]]


poke_stats <- function(name, ...){
  ###
  # This function takes the Pokemon names and returns all the Pokemon
  # stats for those species.
  ###
  url <- paste0("https://pokeapi.co/api/v2/pokemon/",c(name, ...))
  pokedex <- lapply(X = url, FUN = GET)
  pokedex<-lapply(pokedex, '[[', 'content')
  pokedex <- lapply(pokedex, rawToChar)
  pokedex <- lapply(pokedex, fromJSON)

  # Unlisting our data from the API so that we can create a tidy data frame
  pokemon_stat <- map(pokedex, "name")
  base_stat <- map(map(pokedex, "stats"), "base_stat")

  # Initializing the variables whose values I want
  Pokemon <- rep(0, length(pokemon_stat))
  hp <- rep(0, length(pokemon_stat))
  attack  <- rep(0, length(pokemon_stat))
  defense <- rep(0, length(pokemon_stat))
  sp_attack <- rep(0, length(pokemon_stat))
  sp_defense <- rep(0, length(pokemon_stat))
  speed <- rep(0, length(pokemon_stat))

  # Creating a tibble of the Pokemon and their stats
  for(p in 1:length(pokemon_stat)){
    Pokemon[p] <- pokemon_stat[[p]]
    hp[p] <- as.numeric(base_stat[[p]][1])
    attack[p]  <- base_stat[[p]][2]
    defense[p] <- base_stat[[p]][3]
    sp_attack[p] <- base_stat[[p]][4]
    sp_defense[p] <- base_stat[[p]][5]
    speed[p] <- base_stat[[p]][6]
  }
  Pokemon_Stats <- as_tibble(cbind(Pokemon, hp, attack, defense, sp_attack, sp_defense, speed))

# The stats are printed as character values so we just want to change these to numeric
  for(s in 2:7){
      Pokemon_Stats[[s]] <- as.numeric(Pokemon_Stats[[s]])
  }

  return(Pokemon_Stats)
}
```


# Exploratory Data Analysis

## Generating Data Sets

I only want to analyze the first [898 Pokemon] (https://www.wargamer.com/pokemon-trading-card-game/how-many-pokemon-are-there). The PokeAPI is structured so that the first 898 Pokemon are the strictly unique species, while the rest are types of the species that may have a different regional form or are evolved in a special way that grants them special base stats. I only wanted to analyze the base stats from 'normal' wild Pokemon. Because I want to see if there is a [power creep](https://tvtropes.org/pmwiki/pmwiki.php/Main/PowerCreep) as the Pokemon world was built, and not as the player can manipulate their caught Pokemon. I will also do some general exploration of the Pokemon attributes. 


```{r}
# Creating Data Frames
Pokemon_Habitat <- habitat(avail_habitat)
Pokemon_Stats <- poke_stats(avail_pokemon)
Pokemon_Ability <- ability(avail_ability)
Pokemon_Generation <- generation(avail_gen)

# Only querying the first 898 unique pokemon
Pokemon_Stats <- Pokemon_Stats[1:898, ]

# There are no Pokemon unknown or shadow types, so we only need to
# query the first 18 types
Pokemon_Types <- type(1:18)

# Creating a new variable that is the sum of the other statistics
Pokemon_Stats <- Pokemon_Stats %>% mutate(total_stats = hp + attack + defense +
                    sp_attack + sp_defense + speed)

# Here I merging
Pokemon_Stats <- merge(Pokemon_Stats, Pokemon_Generation, by = "Pokemon")

Pokemon_Type1 <- filter(Pokemon_Types, duplicated(Pokemon_Types$Pokemon) == FALSE)
Pokemon_Type2 <- filter(Pokemon_Types, duplicated(Pokemon_Types$Pokemon) == TRUE)

Pokemon_Type1 <- rename(Pokemon_Type1, Type1 = Type)
Pokemon_Type2 <- rename(Pokemon_Type2, Type2 = Type)

# I just want a left join because both Pokemon Types data sets 
# contains the "mega" Pokemon
Pokemon_Type_Stats <- merge(Pokemon_Stats, Pokemon_Type1,
                            by = "Pokemon", all.x = TRUE)
Pokemon_Type_Stats <- merge(Pokemon_Type_Stats, Pokemon_Type2,
                            by = "Pokemon", all.x = TRUE)

# I want to make a table of types, but I don't want to have NA's in
# Type2 because those Pokemon will be excluded so I'm filling in Type1's
# value for Type2 if Type2 is blank. 
Pokemon_Type_Stats <- Pokemon_Type_Stats %>% mutate(
  Type2 = if_else(is.na(Type2) == TRUE, Type1, Type2))

# Using the Quantile Stats, we're also going to make a categorical 
# variable based on the Pokemon's total stats
quantile(Pokemon_Type_Stats$total_stats)

# Here the categories split the total_stats into four groups, based on the 
# data quantiles. 
Pokemon_Type_Stats <- Pokemon_Type_Stats %>% mutate(
  TypeCat = if_else(total_stats <= 320, "poor", 
                if_else(total_stats <= 430.5, "fair", 
                    if_else(total_stats <= 500, "good", "great"))), 
  TypeCat = factor(TypeCat, levels = c("poor", "fair", "good", "great")),)

```


### Pokemon Attribute Exploration

Here we're just getting a feel for the data set and viewing how the Pokemon games may have changed over the course of generations. 

```{r}
# Here I'm doing a full join of the Pokemon_Habitat and Pokemon_Generation
# data sets by Pokemon. 
Habitat_Gen <- merge(Pokemon_Habitat, Pokemon_Generation, by = "Pokemon")

# Here is a table of the Pokemon that would be found in each combination
# of generation and habitat
table(Habitat_Gen$Habitat, Habitat_Gen$Generation)
```


I thought it was surprising that habitats were only provided up to Generation III of the games. According to Bulbagarden(https://bulbapedia.bulbagarden.net/wiki/List_of_Pok%C3%A9mon_by_habitat) and Bulbapedia(https://bulbapedia.bulbagarden.net/wiki/Talk:List_of_Pok%C3%A9mon_by_habitat), the habitat classifications are only a feature in FireRed and LeafGreen, which are reboots of the 1996 Red and Green games. This explains why there are no observations included in our contingency table after Generation III.


```{r}
Pokemon_Type_Plot <- ggplot(data = Pokemon_Types, aes(x = Type)) +
  geom_bar(aes(fill = Type)) +
  labs(title = "Prevalent Pokemon Types", x = "Pokemon Habitats",
     y = "Pokemon Counts") +
  theme(axis.text.x=element_text(angle=45))
Pokemon_Type_Plot

addmargins(table(Pokemon_Type_Stats$Type1, Pokemon_Type_Stats$Type2))
```

### Exploring Generations
##### Is there a power creep between generations of pokemon?
```{r}
Pokemon_Gen_Plot <- ggplot(data = Pokemon_Generation, aes(x = Generation)) +
  geom_bar(aes(fill = Generation)) +
  labs(title = "Number of Pokemon Per Generation", x = "First Gen Appearance",
       y = "Pokemon Counts") +
  theme(axis.text.x=element_text(angle=45))
Pokemon_Gen_Plot
```

So we can see that the Generations with the most Pokemon cohorts is Generation I and Generation V, both which have about 150 Pokemon added for each game. Generation VI is the smallest group of new Pokemon, only adding about 75 more. We should expect that there should be proportional representation of generally strong and generally weak Pokemon in each group. That means we should expect about twice as many strong and weak Pokemon in Generations I and V than in Generation VI, and all the other Generations should fall somewhere between them. 

```{r}
Pokemon_Gen_Plot <- ggplot(data = Pokemon_Type_Stats, aes(x = TypeCat)) +
  geom_bar(aes(fill = TypeCat)) +
  labs(title = "Number of Pokemon Per Generation", x = "First Gen Appearance",
       y = "Pokemon Counts") +
  facet_wrap(vars(Generation)) +
  theme(axis.text.x=element_text(angle=45))
Pokemon_Gen_Plot

table(Pokemon_Type_Stats$Generation, Pokemon_Type_Stats$TypeCat)
```

While there clearly isn't the same proportion of poor, fair, good, and great Pokemon added to each generations, it does not seem that there is any pattern between the Pokemon's total base stats and in what generation they were added. Generation I, II, Generation III do seem to lack great Pokemon, but so does Generation V. Generation IV has the most "great" Pokemon. Because these a categorical variables as well, there is no quantify how much better Generation IV Pokemon are than say Generation II. In otherwords, Generation IV could have most of their great Pokemon, just barely in the upper quantile of the total_stats group. 


```{r}
# Creating a function to return the first quantile of a column
quant1 <- function(col){
  quant <- quantile(col)
  return(quant[2])
}

# Creating a function to return the third quantile of a column
quant3 <- function(col){
  quant <- quantile(col)
  return(quant[4])
}

Summary_total_stats <- Pokemon_Type_Stats %>% group_by(Generation) %>%
  summarise(min_total_stats = min(total_stats),
            q1_total_stats = round(quant1(total_stats)),
            avg_total_stats = round(mean(total_stats)), 
            q3_total_stats = round(quant3(total_stats)),
            max_total_stats = max(total_stats))
Summary_total_stats
```

Here we have the spread of the data of the total_stats for each generation of game. I do think that the max of Generation IV is surprisingly high at 720, while all the other maximum total_stats for each generation is either 680 or 690. Generation IV also has the strongest "weakest" Pokemon. The lowest total_stat for Generation IV is 255, while the next closes two are 200. The absolute lowest total_stat score comes from Generation VIII, taking on a value of 180. All the averages of the total_stats hang around 400 to 450, with the highest total_stats coming from Generation VII and Generation IV, at 452 and 442, respectively. Clearly, Generation IV has some of the strongest Pokemon, based on total_stats. This does not support the idea that Pokemon have gotten progressively stronger as the franchise has continued making games. 


```{r}
Stat_Boxplot <- ggplot(data = Pokemon_Stats) +
  geom_boxplot(mapping = aes(x = total_stats, y = Generation, color = Generation)) +
  coord_flip() +
  theme(axis.text.x=element_text(angle=45))
Stat_Boxplot
```



```{r}
Stat_Hist <- ggplot(data = Pokemon_Stats)+
  geom_histogram(mapping = aes(x = total_stats)) +
  facet_wrap(vars(Generation))
Stat_Hist
```


Because we didn't find any evidence that the total base stats between Pokemon of different generations were different, I thought I may look to see if there was a relationship between the three main base stats - HP, attack, and defense. I think it would make sense that attack and defense may be inversely related since they're opposites of each other in a video game. 

```{r}
HP_Defense <- ggplot(data = Pokemon_Stats, aes(x = hp, y = defense)) +
  geom_point(aes(color = Generation))
HP_Defense
```


```{r}
HP_Attack <- ggplot(data = Pokemon_Stats, aes(x = hp, y = attack)) +
  geom_point(aes(color = Generation))
HP_Attack
```


```{r}
Defense_Attack <- ggplot(data = Pokemon_Stats, aes(x = defense, y = attack)) +
  geom_point(aes(color = Generation))
Defense_Attack
```


